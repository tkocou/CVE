## Written by Thomas Kocourek, N4FWD. (c) 2022
# As a Contact Volunteer Examiner (CVE), I needed 
# a database to manage thye data of the applicants who my 
# VE team have tested. The purpose is for circumstances
# where the applicant came back for a license upgrade.
#
# sq3lite databases are good for 1 billion rows (2^64 rows - give or take a few million)
# One will run out of hard drive space before running out of sq3lite rows.
#
## Since this is a GUI based program
import tkinter as tk
from tkinter import ttk
from tkinter import messagebox as mb
from tkinter.filedialog import asksaveasfile

import os
import sys
import re
import sqlite3 as sql


try:
    import pandas as pd
except:
## this result should not happen with the compiled executable.
    mb.showwarning("ERROR!","Python library 'pandas' cannot be found.")
    sys.exit()


## import other 'py' files
import DBHandler as dh
import cve_db_setup as cdb
import cve_utilities as ut
import global_var as gv
import do_sql_query as dq
import progress as pb
import csv_save as cv
import JSON_import as ji
import session_report as sr
import ve_report as vr

class App(tk.Tk):
    def __init__(self):
        super().__init__()
        ## get path to working directory
        self.environment = ut.set_environment()
        
        ## set up window dimensions, title , etc.
        self.title(gv.program)
        self.resizable(width=False, height=False)
        
        self.sort_key = tk.StringVar()
        self.sort_key.set(gv.def_sort_key)
        self.sort_dir = True
        self.local_sql_dict = {}
        ## used with listbox selection
        self.selected_items = tuple()
        self.selected_fields = []
        ## used to transfer listbox selection
        self.sel_col_items = []
        self.sel_parm_items = []
        self.sql_query_dict = {}
        ## used with transferring from treeview list to parameter selection
        self.tv_flag = False
        ## save SQL results
        self.text_text = ""
        self.text_list = []
        self.csv_dict_list = []
        
        ## Let's start the window in the center of the desktop screen
        window_height = 800
        window_width = 1280
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        x_cordinate = int((screen_width/2) - (window_width/2))
        y_cordinate = int((screen_height/2) - (window_height/2))
        self.geometry("{}x{}+{}+{}".format(window_width, window_height, x_cordinate, y_cordinate))
        
        self.style = ttk.Style()
        self.style.theme_use("clam")
        self.style.configure("Treeview",
            background="#c0ffc0",
            foreground="black",
            fieldbackground="#c0ffc0"
            )
        self.style.map("Treeview",
            background=[("selected","green")])
        
        
        self.columnconfigure(0, weight=12)
        self.columnconfigure(1, weight=1)
        self.columnconfigure(2, weight=12)
        self.columnconfigure(3, weight=1)

        self.rowconfigure(0,weight=1)
        self.rowconfigure(1,weight=1)
        self.rowconfigure(2,weight=24)
        self.rowconfigure(3,weight=6)
        self.rowconfigure(4,weight=1)
        

        ## setup window menu
        self.set_menu()
        
        ## setup database handling and leave it open
        self.db_path = gv.cve_database
        self.db_obj = dh.DB_object(self.db_path)
        self.set_gui()
        self.refresh_screen()
        
        
    def set_menu(self):
        self.menubar = tk.Menu(self)
        self.filemenu = tk.Menu(self.menubar, tearoff = 0)
        self.filemenu.add_command(label="Import Session JSON files",command=lambda: ji.read_JSON_files(self))
        self.filemenu.add_command(label="Import CSV files", command=self.read_csv_files)
        self.filemenu.add_separator()
        self.filemenu.add_command(label="Exit", command=self.goodbye)
        
        ## menu items for reports
        ##
        self.reportmenu = tk.Menu(self.menubar, tearoff = 0)
        self.reportmenu.add_command(label="Generate Session Report", command=lambda: sr.sr_data(self))
        self.reportmenu.add_command(label="VEs Report", command=lambda: vr.vr_data(self))
        
        
        self.helpmenu = tk.Menu(self.menubar, tearoff = 0)
        self.helpmenu.add_command(label="About", command=self.about)
        
        self.menubar.add_cascade(label="File", menu = self.filemenu)
        self.menubar.add_cascade(label="Reports", menu = self.reportmenu)
        self.menubar.add_cascade(label="About", menu = self.helpmenu)
        self.config(menu = self.menubar)
        
    def set_gui(self):
        ## Labels for areas
        self.list_label = tk.Label(self, text="Query Fields - Multiple Select")
        self.list_label.grid(row=1, column=0, sticky='w', padx=(50,0))
        
        self.appl_tv = tk.Label(self, text="Applicants - Double click for details")
        self.appl_tv.grid(row=1, column=2, sticky='w', padx=(50,0))
        
        ## create a list box
        self.col_query = tk.Listbox(self, selectmode="multiple")
        self.col_query.configure(
            background="#c0c0ff",
            foreground="black",
            selectbackground="#c0ffc0")
        
        self.col_query.bind('<ButtonRelease-1>',self.fetch_col_query)
        self.col_query.grid(row=2, column=0, sticky='nsew', padx=(10,0), pady=(0,10))
        self.quscrollbar = ttk.Scrollbar(self, orient=tk.VERTICAL, command=self.col_query.yview)
        self.col_query.configure(yscroll=self.quscrollbar.set)
        self.quscrollbar.grid(row=2, column=1, sticky='ns', padx=(0,0), pady=(0,10))
        
        ## populate the list box
        index = 0
        for field in gv.data_appl_cols_listbox:
            self.col_query.insert(index,gv.data_appl_cols_listbox[index])
            index += 1
        
        ## set up an overlay frame
        self.quframe = tk.Frame(self)
        self.quframe.grid(row=3, column=0, columnspan=2, sticky='nsew', padx=10, pady=(0,10))
        
        ## buttons within overlay
        self.clear1_button = tk.Button(self.quframe, text = 'Clear Selection', bg="#d0d0ff", command = self.clear_listbox_selection)
        self.clear1_button.grid(row=3, column=0, sticky='nw', padx=(0,8), pady=2)
        
        self.make_query_button = tk.Button(self.quframe, text = 'NEXT', bg="#ffb020", command = self.do_query)
        self.make_query_button.grid(row=3, column=1, sticky='ne',padx=(0,8), pady=2)
        
        self.set_select_col =tk.Button(self.quframe, text='Set Select Column', bg="#d0d0ff", command=self.set_sel_cols)
        self.set_select_col.grid(row=4, column=0, sticky='nw', padx=(0,8), pady=2)
        
        self.set_param_col = tk.Button(self.quframe, text='Set Parameter Column', bg="#d0d0ff", command=self.set_parm_cols)
        self.set_param_col.grid(row=4, column=1, sticky='ne', padx=(0,8), pady=2)
        
        
        ## create a treeview
        self.datadb = ttk.Treeview(self, show='headings', selectmode='browse')
        self.datadb["columns"] =  gv.appl_treeview_cols
        self.datadb.column('index',width=40, minwidth=40)
        self.datadb.column('frn',width=80, minwidth=80)
        self.datadb.column('sessionDate',width=80, minwidth=80)
        self.datadb.column('teamId',width=160,minwidth=80)
        
        self.datadb.heading('index', text="Index", anchor='w')
        self.datadb.heading('frn', text="FRN",anchor='w')
        self.datadb.heading('sessionDate', text="Session Date",anchor='w')
        self.datadb.heading('teamId', text="Team Id",anchor='w')
        
        ## capture treeview selection and double-click action selection
        self.datadb.bind('<ButtonRelease-1>',self.fetch_applicant)
        self.datadb.bind('<Double-1>', self.view_applicant)
        self.datadb.grid(row=2, column=2, sticky='nsew', padx=(10,0), pady=(0,10))
        self.dbscrollbar = ttk.Scrollbar(self, orient=tk.VERTICAL, command=self.datadb.yview)
        self.datadb.configure(yscroll=self.dbscrollbar.set)
        self.dbscrollbar.grid(row=2, column=3, sticky='ns', padx=(0,10), pady=(0,10))
        
        ## set up an overlay frame
        self.tvframe = tk.Frame(self)
        self.tvframe.grid(row=3, column=2, columnspan=2, sticky='nsew', padx=10, pady=(0,10))
        
        ## buttons within overlay
        
        self.clear2_button = tk.Button(self.tvframe, text = 'Clear Selection', bg="#d0ffd0", command = self.clear_treeview)
        self.clear2_button.grid(row=3, column=2, sticky='nw', padx=(0,8), pady=0)
        self.dir_sort_button = tk.Button(self.tvframe, text = 'Sort Direction Toggle', bg="#d0ffd0", command = self.toggle_dir)
        self.dir_sort_button.grid(row=3, column=3, sticky='nw',padx=(0,8), pady=0 )
        self.resort_button = tk.Button(self.tvframe, text='Sort List', bg="#d0ffd0", command=self.refresh_screen)
        self.resort_button.grid(row=4, column=2, sticky='ne', padx=(0,8), pady=0)
        
        ## set up radio buttons for sort
        for fld in gv.rb_cols:
            self.rb = ttk.Radiobutton(self.tvframe, text=fld[0], value=fld[1], variable=self.sort_key)
            self.rb.grid(row=4, column=3, sticky='we', padx=fld[2])
        
    def fetch_applicant(self,env):
        ## get single data line from SQL based on treeview list
        ## invoked when applicant is selected to
        ## get info to prepopulate parameter fields
        ##
        
        db_ref_id = 0
        
        ## get a reference to the line clicked on in treeview
        _iid = self.datadb.focus()
        ## convert reference to a dictionary of data
        reference = self.datadb.item(_iid)
        ## extract the SQL reference id number
        try:
            db_ref_id = reference['values'][0]
            ## read the SQL DB
            c = self.db_obj.get_cursor()
            c.execute("SELECT * FROM applicant WHERE id = ?",[db_ref_id])
            ## method returns a tuple
            applicant = c.fetchone()
            ## convert to a 'list' 
            dlist = list(applicant)
            ## remove sql index
            dlist.pop(0)
            ## create a data dictionary from SQL result, for the SQL query function
            self.local_sql_dict = {}
            index = 0
            stopping = len(gv.data_json_appl_cols)
            while index < stopping:
                self.local_sql_dict.update({gv.data_json_appl_cols[index]:dlist[index].replace('"','')})
                index += 1
            self.tv_flag = True
        except:
            pass
        
    def fetch_col_query(self,event):
        self.selected_fields = []
        self.selected_items = list(self.col_query.curselection())
        for x in self.selected_items:
            self.selected_fields.append(gv.data_json_appl_cols[x])

        
    def do_query(self):
        ## invoke query by button. will not work calling get_by_field directly in gui
        dq.get_by_field(self)
        self.clear_listbox_selection()
        self.clear_treeview()
        
    def set_sel_cols(self):
        self.sel_col_items.extend(self.selected_fields) 
        ## reset GUI
        self.clear_listbox()
        
    def set_parm_cols(self):
        ## fix sel_parm_items based on self.tv_flag
        if self.tv_flag:
            index = 0
            stopping = len(gv.data_appl_cols)
            ## note to self, check for no flags being set
            while index < stopping:
                if self.local_sql_dict[gv.app_field_dict[index]] != 'None':
                    self.sel_parm_items.append(gv.data_appl_cols[index])
                index += 1
            
        else:
            self.sel_parm_items = self.selected_fields
        ## if applicant has been selected from treeview
        ## 
        ## reset GUI
        self.clear_listbox()
        
    def clear_listbox(self):
        self.col_query.selection_clear(0, 'end')
        self.selected_items = []
        
    def clear_listbox_selection(self):
        ## reset any selections plus GUI
        self.sel_col_items = []
        self.sel_parm_items = []
        #self.dl = []
        self.tv_flag = False
        self.clear_listbox()
        
    def clear_treeview(self):
        if len(self.datadb.selection()) > 0:
            self.datadb.selection_remove(self.datadb.selection()[0])
            self.local_sql_dict = {}

    def read_csv_files(self):
        tmp_dir = os.path.join(self.environment,gv.cve_dir)
        csv_dir = os.path.join(tmp_dir,gv.csv_store)
        cve_db = gv.cve_database
        
        db_conn = self.db_obj.get_connection()
        ## init progress bar widget as a toplevel window
        progress_bar = pb.Progress(self)
        
        ## get a list of files
        file_list = os.listdir(csv_dir)
        session_date = ""
        
        for file_line in file_list:
            progress_bar.update_pb()
            
            ## extract session id from filename
            sid_list = file_line.split('_') # team id is element one
            
            csv_file = os.path.join(csv_dir,file_line)
            tmp_df = pd.read_csv(csv_file)
            ## extract session date from the first row - 'created' column
            tmp_date = tmp_df["created"].iloc[0]
            session_date = tmp_date[:15]
            ## replace any null value with 'None'
            tmp_df.fillna("None",inplace = True)
            
            ## Do we have a proper CSV file?
            try:
                csv_df = tmp_df[gv.data_appl_cols]
            ## We are missing fields, import just the common fields
            except KeyError:
                csv_df = tmp_df[gv.csv_common_cols]
            
            ## Let's create data for the missing fields
            row_count = csv_df.shape[0]
            e2_list = []
            e3_list = []
            e4_list = []
            sessionDate_list = []
            teamId_list = []
            
            x = 0
            while x < row_count:
                e2_list.append('None')
                e3_list.append('None')
                e4_list.append('None')
                sessionDate_list.append(session_date)
                teamId_list.append(sid_list[1])
                x += 1
            ## check for potentially missing fields to dataframe
            ## if needed, add missing data
            if 'E2' not in csv_df.columns:
                csv_df.insert(loc=len(csv_df.columns), column='E2', value= e2_list)
            if 'E3' not in csv_df.columns:
                csv_df.insert(loc=len(csv_df.columns), column='E3', value= e3_list)
            if 'E4' not in csv_df.columns:
                csv_df.insert(loc=len(csv_df.columns), column='E4', value= e4_list)
            if 'sessionDate' not in csv_df.columns:
                csv_df.insert(loc=len(csv_df.columns), column='sessionDate', value= sessionDate_list)
            if 'teamId' not in csv_df.columns:
                csv_df.insert(loc=len(csv_df.columns), column='teamId', value= teamId_list)
                
            ## save only designated columns of data
            csv_df[gv.data_appl_cols].to_sql('applicant', con=db_conn, if_exists='append', index=False)
            ## remove the file after importing the data
            os.remove(csv_file)

        progress_bar.close()
        self.refresh_screen()
        
    def create_csv(self):
        ## Use self.csv_dict_list populated in do_sql_query()
        cv.save_as_csv(self)
        
    def refresh_screen(self):
        ## Clear previous entries in Treeview
        tree = self.datadb.get_children()

        for item in tree:
            self.datadb.delete(item)
            
        ## read in all applicants stored in database
        ## 'applicants' will be a list of tuples
        applicants = self.get_all_database()
        ## do we have an empty database
        if applicants != None:
            applicants.sort(key=lambda tup: tup[int(self.sort_key.get())], reverse=self.sort_dir)

            ## Add each applicant data to treeview, one at a time
            for applicant in applicants:
                appl_list = []
                appl_list.append(applicant[0]) # Index
                appl_list.append(applicant[6]) # FRN
                appl_list.append(applicant[13]) # session date
                appl_list.append(applicant[14]) # session id
                appl_tuple = tuple(appl_list)
                self.datadb.insert('','end', values=appl_tuple)

    def view_applicant(self, ev):
        ## This event handler shows full record of applicant
        ##
        appl_dict = {}
        ## get a reference to the line clicked on
        _iid = self.datadb.focus()
        ## convert reference to a dictionary of data
        reference = self.datadb.item(_iid)
        ## extract the SQL reference id number
        db_ref_id = reference['values'][0]
        ## read the SQL DB
        c = self.db_obj.get_cursor()
        c.execute("SELECT * FROM applicant WHERE id = ?",[db_ref_id])
        ## method returns a tuple
        applicant = c.fetchone()
        ## convert to a 'list' and
        ## remove the SQL reference
        dlist = list(applicant)
        dlist.pop(0)
        ad = dict.fromkeys(gv.data_json_appl_cols,"")
        ## Build a new list
        index = 0
        ## 
        for e in dlist:
            try:
                ad[gv.appl_field_dict[str(index)]] = e.replace('"','')
            except:
                pass
            index += 1
        ## format data for display
        if ad['suffix'] == " " or len(ad['suffix']) < 1 :
            display_string = "name: {0} {1} {2}{3}\n\n{4}\n\nfrn: {5}\nCallsign: {6}\nfrom: {7}, {8}\non: {9}\nTeam Id: {10}".format(ad['firstname'],ad['middle'],ad['lastname'],ad['suffix'],ad['email'],ad['frn'],ad['callsign'],ad['city'],ad['state'],ad['sessionDate'],ad['teamId'])
        else:
            display_string = "name: {0} {1} {2}, {3}\n\n{4}\n\nfrn: {5}\nCallsign: {6}\nfrom: {7}, {8}\non: {9}\nTeam Id: {10}".format(ad['firstname'],ad['middle'],ad['lastname'],ad['suffix'],ad['email'],ad['frn'],ad['callsign'],ad['city'],ad['state'],ad['sessionDate'],ad['teamId'])
        ##
        ## pop up a tkinter message box with formatted data
        mb.showinfo("Applicant Detail",display_string)
        
    def get_all_database(self):
        conn = self.db_obj.get_connection()
        curs = self.db_obj.get_cursor()
        message = "SELECT * FROM applicant;"
        self.db_obj.set_SQL(message)
        ## method returns a list of tuples
        records = self.db_obj.fetch_all_SQL()
        ## return a list of tuples
        return records
            
    def toggle_dir(self):
        if self.sort_dir:
            self.sort_dir = False
        else:
            self.sort_dir = True
        self.refresh_screen()
        
    def goodbye(self):
        self.db_obj.close_SQL()
        sys.exit()
        
    def about(self):
        info = gv.program+"\n\n"
        info += "Version: "+gv.version+'\n\n'
        info += "Written by Thomas Kocourek, N4FWD\n\n"
        info += "Copyright 2022"+'\n\n'
        info += "Released under the GNU 3 License \n\n"
        mb.showinfo('About',info)

def main():
    ## set-up database. cdb is imported at beginning of this file
    environment = cdb.setup()
    if not environment:
        rw = tk.Tk()
        rw.overrideredirect(1)
        rw.withdraw()
        mb.showwarning('Error','Problem with environment or permissions!')
        rw.destroy()
        sys.exit()
    app = App()
    app.mainloop()
    
if __name__ == '__main__':
    main()